\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{enumitem}
\geometry{top=3cm, bottom=2.5cm, left=3cm, right=2.5cm}

\title{ARM Invaders: Relatório do Projeto}
\author{Antonio Fassini \\ Pedro Fassini}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\onehalfspacing

\chapter{Introdução}
O projeto \textbf{ARM Invaders} é um mini-jogo/simulador interativo, inspirado no clássico \textit{Space Invaders}, mas com foco didático na manipulação de registradores ARM e flags do processador.  

Ele foi desenvolvido na linguagem C, com uso de trechos de \textit{inline Assembly}, e é executado diretamente no terminal da Raspberry Pi ou em ambientes Linux/WSL.  
A proposta é transformar conceitos abstratos de Organização e Arquitetura de Computadores em uma experiência visual e interativa, permitindo ao aluno observar em tempo real o funcionamento de registradores, flags e instruções básicas da ISA ARM.

\chapter{Objetivos e Motivação}
O ARM Invaders busca:
\begin{itemize}
    \item Tornar o estudo de registradores ARM mais visual e acessível, facilitando a fixação de conceitos fundamentais.
    \item Demonstrar, de forma prática, como instruções simples modificam o estado interno de um processador.
    \item Oferecer um recurso multiplataforma, rodando apenas no terminal, sem dependências gráficas pesadas.
    \item Aproximar conteúdos da disciplina (Arquitetura e Redes) do funcionamento real de hardware e sistemas.
\end{itemize}

\chapter{Relação com a Disciplina}
Embora o foco da disciplina esteja em protocolos e comunicação em rede, todo sistema computacional depende de operações internas da CPU.  
O simulador permite:
\begin{itemize}
    \item Entender como dados são processados internamente na CPU.
    \item Visualizar a influência de instruções de baixo nível sobre desempenho e eficiência.
    \item Conectar hardware, sistema operacional e aplicações em rede.
    \item Explorar o ciclo \textit{fetch-decode-execute} em um contexto lúdico.
\end{itemize}

\chapter{Decisões de Design}
As principais escolhas foram:
\begin{itemize}
    \item \textbf{Simplicidade intencional:} operações básicas (ADD, SUB, MUL, MOV) garantem curva de aprendizado suave.
    \item \textbf{Terminal puro:} compatibilidade com qualquer ambiente Linux/WSL/Raspberry Pi.
    \item \textbf{Código comentado:} cada função foi documentada para incentivar exploração e modificações.
    \item \textbf{Extensibilidade:} comandos adicionais podem ser facilmente implementados no interpretador.
\end{itemize}

\chapter{Descrição da Lógica e Funcionalidades}
A implementação segue esta lógica:
\begin{enumerate}
    \item \textbf{Inicialização:} cria registradores e flags com valores iniciais.
    \item \textbf{HUD:} mostra registradores como “naves” com barras de vida, números e símbolos.
    \item \textbf{Entrada:} usuário escolhe registrador e operação (ADD, SUB, MUL, MOV).
    \item \textbf{Execução:} a operação é realizada em C com \textit{inline Assembly} exibido no terminal.
    \item \textbf{Flags:} N, Z, C, V são atualizadas após cada instrução.
    \item \textbf{Explosão:} quando o valor chega a zero, a nave “explode” em ASCII-art.
    \item \textbf{Loop principal:} mantém o jogo ativo enquanto houver registradores com vida.
\end{enumerate}

\section*{Funcionalidades Implementadas}
\begin{itemize}
    \item Visualização contínua dos registradores e flags.
    \item Execução das operações aritméticas: ADD, SUB, MUL, MOV.
    \item Uso de cores ANSI para realce.
    \item HUD com animações simples em ASCII.
    \item Geração de valores aleatórios (\texttt{rand}).
    \item Salvamento e carregamento de estado (save/load).
    \item Execução automatizada de comandos (scripts).
\end{itemize}

\chapter{Conexão com Conteúdos Teóricos}
\begin{itemize}
    \item \textbf{Registradores:} simulam armazenamento temporário de dados.
    \item \textbf{Flags:} N/Z/C/V exibem resultados das operações.
    \item \textbf{Memória:} gerenciamento de estados e persistência via arquivos de texto.
    \item \textbf{ISA ARM:} instruções básicas demonstradas com trechos reais de Assembly.
    \item \textbf{Ciclo de Execução:} o loop do jogo reflete o ciclo \textit{fetch-decode-execute}.
\end{itemize}

\chapter{Estrutura do Repositório}
\begin{verbatim}
arm_invaders/
│── src/        # Código-fonte
│── doc/        # Relatórios e documentação
│── media/      # Imagens, vídeos e capturas
│── scripts/    # Exemplos de automação
│── LICENSE     # Licença do projeto
│── Makefile    # Script de compilação
└── README.md   # Documentação resumida
\end{verbatim}

\chapter{Como Compilar e Executar}
\section*{Requisitos}
\begin{itemize}
    \item \texttt{gcc} (instalar via: \texttt{sudo apt install build-essential})
\end{itemize}

\section*{Compilação}
\begin{verbatim}
make
\end{verbatim}

\section*{Execução}
\begin{verbatim}
make run
\end{verbatim}

\chapter{Resultados e Discussão}
O ARM Invaders permitiu observar:
\begin{itemize}
    \item Impacto imediato de instruções em registradores e flags.
    \item Relação entre baixo nível (Assembly) e lógica de alto nível (C).
    \item Desafios de sincronização e atualização em tempo real.
    \item Potencial de expansão para novos comandos e interfaces.
\end{itemize}

\chapter{Conclusão}
O projeto cumpriu sua função didática: aproximar a teoria da prática em Arquitetura ARM.  
Além de reforçar conceitos como registradores, flags e instruções, mostrou que é possível criar experiências motivadoras e visuais mesmo em ambientes simples como o terminal.

\chapter{Licença}
Este projeto é distribuído sob a licença MIT. Consulte o arquivo LICENSE para mais detalhes.

\end{document}

